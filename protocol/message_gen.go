package protocol

// Code generated by github.com/tinylib/msgp DO NOT EDIT.

import (
	"github.com/tinylib/msgp/msgp"
)

// DecodeMsg implements msgp.Decodable
func (z *AllowResolution) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "addr":
			err = dc.ReadExactBytes((z.Address)[:])
			if err != nil {
				err = msgp.WrapError(err, "Address")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *AllowResolution) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "addr"
	err = en.Append(0x81, 0xa4, 0x61, 0x64, 0x64, 0x72)
	if err != nil {
		return
	}
	err = en.WriteBytes((z.Address)[:])
	if err != nil {
		err = msgp.WrapError(err, "Address")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *AllowResolution) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "addr"
	o = append(o, 0x81, 0xa4, 0x61, 0x64, 0x64, 0x72)
	o = msgp.AppendBytes(o, (z.Address)[:])
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *AllowResolution) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "addr":
			bts, err = msgp.ReadExactBytes(bts, (z.Address)[:])
			if err != nil {
				err = msgp.WrapError(err, "Address")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *AllowResolution) Msgsize() (s int) {
	s = 1 + 5 + msgp.ArrayHeaderSize + (16 * (msgp.ByteSize))
	return
}

// DecodeMsg implements msgp.Decodable
func (z *AllowResolutionReply) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z AllowResolutionReply) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 0
	err = en.Append(0x80)
	if err != nil {
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z AllowResolutionReply) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 0
	o = append(o, 0x80)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *AllowResolutionReply) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z AllowResolutionReply) Msgsize() (s int) {
	s = 1
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DisallowResolution) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "addr":
			err = dc.ReadExactBytes((z.Address)[:])
			if err != nil {
				err = msgp.WrapError(err, "Address")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DisallowResolution) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "addr"
	err = en.Append(0x81, 0xa4, 0x61, 0x64, 0x64, 0x72)
	if err != nil {
		return
	}
	err = en.WriteBytes((z.Address)[:])
	if err != nil {
		err = msgp.WrapError(err, "Address")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *DisallowResolution) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "addr"
	o = append(o, 0x81, 0xa4, 0x61, 0x64, 0x64, 0x72)
	o = msgp.AppendBytes(o, (z.Address)[:])
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DisallowResolution) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "addr":
			bts, err = msgp.ReadExactBytes(bts, (z.Address)[:])
			if err != nil {
				err = msgp.WrapError(err, "Address")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DisallowResolution) Msgsize() (s int) {
	s = 1 + 5 + msgp.ArrayHeaderSize + (16 * (msgp.ByteSize))
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DisallowResolutionReply) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z DisallowResolutionReply) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 0
	err = en.Append(0x80)
	if err != nil {
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z DisallowResolutionReply) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 0
	o = append(o, 0x80)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DisallowResolutionReply) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z DisallowResolutionReply) Msgsize() (s int) {
	s = 1
	return
}

// DecodeMsg implements msgp.Decodable
func (z *EmptyReply) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z EmptyReply) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 0
	err = en.Append(0x80)
	if err != nil {
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z EmptyReply) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 0
	o = append(o, 0x80)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *EmptyReply) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z EmptyReply) Msgsize() (s int) {
	s = 1
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Error) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "code":
			z.Code, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "Code")
				return
			}
		case "desc":
			z.Description, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Description")
				return
			}
		case "details":
			z.Details, err = dc.ReadIntf()
			if err != nil {
				err = msgp.WrapError(err, "Details")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z Error) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "code"
	err = en.Append(0x83, 0xa4, 0x63, 0x6f, 0x64, 0x65)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.Code)
	if err != nil {
		err = msgp.WrapError(err, "Code")
		return
	}
	// write "desc"
	err = en.Append(0xa4, 0x64, 0x65, 0x73, 0x63)
	if err != nil {
		return
	}
	err = en.WriteString(z.Description)
	if err != nil {
		err = msgp.WrapError(err, "Description")
		return
	}
	// write "details"
	err = en.Append(0xa7, 0x64, 0x65, 0x74, 0x61, 0x69, 0x6c, 0x73)
	if err != nil {
		return
	}
	err = en.WriteIntf(z.Details)
	if err != nil {
		err = msgp.WrapError(err, "Details")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z Error) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "code"
	o = append(o, 0x83, 0xa4, 0x63, 0x6f, 0x64, 0x65)
	o = msgp.AppendUint32(o, z.Code)
	// string "desc"
	o = append(o, 0xa4, 0x64, 0x65, 0x73, 0x63)
	o = msgp.AppendString(o, z.Description)
	// string "details"
	o = append(o, 0xa7, 0x64, 0x65, 0x74, 0x61, 0x69, 0x6c, 0x73)
	o, err = msgp.AppendIntf(o, z.Details)
	if err != nil {
		err = msgp.WrapError(err, "Details")
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Error) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "code":
			z.Code, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Code")
				return
			}
		case "desc":
			z.Description, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Description")
				return
			}
		case "details":
			z.Details, bts, err = msgp.ReadIntfBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Details")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z Error) Msgsize() (s int) {
	s = 1 + 5 + msgp.Uint32Size + 5 + msgp.StringPrefixSize + len(z.Description) + 8 + msgp.GuessSize(z.Details)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ForwardRawEncryptedMessage) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z ForwardRawEncryptedMessage) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 0
	err = en.Append(0x80)
	if err != nil {
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z ForwardRawEncryptedMessage) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 0
	o = append(o, 0x80)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ForwardRawEncryptedMessage) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z ForwardRawEncryptedMessage) Msgsize() (s int) {
	s = 1
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ForwardRawEncryptedMessageReply) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z ForwardRawEncryptedMessageReply) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 0
	err = en.Append(0x80)
	if err != nil {
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z ForwardRawEncryptedMessageReply) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 0
	o = append(o, 0x80)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ForwardRawEncryptedMessageReply) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z ForwardRawEncryptedMessageReply) Msgsize() (s int) {
	s = 1
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ForwardRawMessage) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z ForwardRawMessage) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 0
	err = en.Append(0x80)
	if err != nil {
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z ForwardRawMessage) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 0
	o = append(o, 0x80)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ForwardRawMessage) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z ForwardRawMessage) Msgsize() (s int) {
	s = 1
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ForwardRawMessageReply) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z ForwardRawMessageReply) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 0
	err = en.Append(0x80)
	if err != nil {
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z ForwardRawMessageReply) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 0
	o = append(o, 0x80)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ForwardRawMessageReply) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z ForwardRawMessageReply) Msgsize() (s int) {
	s = 1
	return
}

// DecodeMsg implements msgp.Decodable
func (z *GetDiscoveryKey) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z GetDiscoveryKey) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 0
	err = en.Append(0x80)
	if err != nil {
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z GetDiscoveryKey) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 0
	o = append(o, 0x80)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *GetDiscoveryKey) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z GetDiscoveryKey) Msgsize() (s int) {
	s = 1
	return
}

// DecodeMsg implements msgp.Decodable
func (z *GetDiscoveryKeyReply) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "key":
			z.DiscoveryKey, err = dc.ReadBytes(z.DiscoveryKey)
			if err != nil {
				err = msgp.WrapError(err, "DiscoveryKey")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *GetDiscoveryKeyReply) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "key"
	err = en.Append(0x81, 0xa3, 0x6b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteBytes(z.DiscoveryKey)
	if err != nil {
		err = msgp.WrapError(err, "DiscoveryKey")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *GetDiscoveryKeyReply) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "key"
	o = append(o, 0x81, 0xa3, 0x6b, 0x65, 0x79)
	o = msgp.AppendBytes(o, z.DiscoveryKey)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *GetDiscoveryKeyReply) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "key":
			z.DiscoveryKey, bts, err = msgp.ReadBytesBytes(bts, z.DiscoveryKey)
			if err != nil {
				err = msgp.WrapError(err, "DiscoveryKey")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *GetDiscoveryKeyReply) Msgsize() (s int) {
	s = 1 + 4 + msgp.BytesPrefixSize + len(z.DiscoveryKey)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *GetPrivacySettings) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z GetPrivacySettings) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 0
	err = en.Append(0x80)
	if err != nil {
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z GetPrivacySettings) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 0
	o = append(o, 0x80)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *GetPrivacySettings) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z GetPrivacySettings) Msgsize() (s int) {
	s = 1
	return
}

// DecodeMsg implements msgp.Decodable
func (z *GetPrivacySettingsReply) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "discoverable":
			z.Discoverable, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Discoverable")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z GetPrivacySettingsReply) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "discoverable"
	err = en.Append(0x81, 0xac, 0x64, 0x69, 0x73, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x61, 0x62, 0x6c, 0x65)
	if err != nil {
		return
	}
	err = en.WriteBool(z.Discoverable)
	if err != nil {
		err = msgp.WrapError(err, "Discoverable")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z GetPrivacySettingsReply) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "discoverable"
	o = append(o, 0x81, 0xac, 0x64, 0x69, 0x73, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x61, 0x62, 0x6c, 0x65)
	o = msgp.AppendBool(o, z.Discoverable)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *GetPrivacySettingsReply) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "discoverable":
			z.Discoverable, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Discoverable")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z GetPrivacySettingsReply) Msgsize() (s int) {
	s = 1 + 13 + msgp.BoolSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Introduce) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "challenge":
			z.Challenge, err = dc.ReadBytes(z.Challenge)
			if err != nil {
				err = msgp.WrapError(err, "Challenge")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Introduce) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "challenge"
	err = en.Append(0x81, 0xa9, 0x63, 0x68, 0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65)
	if err != nil {
		return
	}
	err = en.WriteBytes(z.Challenge)
	if err != nil {
		err = msgp.WrapError(err, "Challenge")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Introduce) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "challenge"
	o = append(o, 0x81, 0xa9, 0x63, 0x68, 0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65)
	o = msgp.AppendBytes(o, z.Challenge)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Introduce) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "challenge":
			z.Challenge, bts, err = msgp.ReadBytesBytes(bts, z.Challenge)
			if err != nil {
				err = msgp.WrapError(err, "Challenge")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Introduce) Msgsize() (s int) {
	s = 1 + 10 + msgp.BytesPrefixSize + len(z.Challenge)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *IntroduceReply) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "name":
			z.Name, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z IntroduceReply) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "name"
	err = en.Append(0x81, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Name)
	if err != nil {
		err = msgp.WrapError(err, "Name")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z IntroduceReply) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "name"
	o = append(o, 0x81, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *IntroduceReply) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z IntroduceReply) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Name)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *IntroduceRequest) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "addr":
			err = dc.ReadExactBytes((z.Address)[:])
			if err != nil {
				err = msgp.WrapError(err, "Address")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *IntroduceRequest) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "addr"
	err = en.Append(0x81, 0xa4, 0x61, 0x64, 0x64, 0x72)
	if err != nil {
		return
	}
	err = en.WriteBytes((z.Address)[:])
	if err != nil {
		err = msgp.WrapError(err, "Address")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *IntroduceRequest) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "addr"
	o = append(o, 0x81, 0xa4, 0x61, 0x64, 0x64, 0x72)
	o = msgp.AppendBytes(o, (z.Address)[:])
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *IntroduceRequest) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "addr":
			bts, err = msgp.ReadExactBytes(bts, (z.Address)[:])
			if err != nil {
				err = msgp.WrapError(err, "Address")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *IntroduceRequest) Msgsize() (s int) {
	s = 1 + 5 + msgp.ArrayHeaderSize + (16 * (msgp.ByteSize))
	return
}

// DecodeMsg implements msgp.Decodable
func (z *IntroduceRequestReply) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "challenge":
			z.Challenge, err = dc.ReadBytes(z.Challenge)
			if err != nil {
				err = msgp.WrapError(err, "Challenge")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *IntroduceRequestReply) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "challenge"
	err = en.Append(0x81, 0xa9, 0x63, 0x68, 0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65)
	if err != nil {
		return
	}
	err = en.WriteBytes(z.Challenge)
	if err != nil {
		err = msgp.WrapError(err, "Challenge")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *IntroduceRequestReply) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "challenge"
	o = append(o, 0x81, 0xa9, 0x63, 0x68, 0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65)
	o = msgp.AppendBytes(o, z.Challenge)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *IntroduceRequestReply) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "challenge":
			z.Challenge, bts, err = msgp.ReadBytesBytes(bts, z.Challenge)
			if err != nil {
				err = msgp.WrapError(err, "Challenge")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *IntroduceRequestReply) Msgsize() (s int) {
	s = 1 + 10 + msgp.BytesPrefixSize + len(z.Challenge)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *MessageHeader) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "sig":
			z.Signature, err = dc.ReadBytes(z.Signature)
			if err != nil {
				err = msgp.WrapError(err, "Signature")
				return
			}
		case "src":
			err = dc.ReadExactBytes((z.Source)[:])
			if err != nil {
				err = msgp.WrapError(err, "Source")
				return
			}
		case "dst":
			err = dc.ReadExactBytes((z.Destination)[:])
			if err != nil {
				err = msgp.WrapError(err, "Destination")
				return
			}
		case "size":
			z.Size, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Size")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *MessageHeader) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 5
	// write "type"
	err = en.Append(0x85, 0xa4, 0x74, 0x79, 0x70, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Type)
	if err != nil {
		err = msgp.WrapError(err, "Type")
		return
	}
	// write "sig"
	err = en.Append(0xa3, 0x73, 0x69, 0x67)
	if err != nil {
		return
	}
	err = en.WriteBytes(z.Signature)
	if err != nil {
		err = msgp.WrapError(err, "Signature")
		return
	}
	// write "src"
	err = en.Append(0xa3, 0x73, 0x72, 0x63)
	if err != nil {
		return
	}
	err = en.WriteBytes((z.Source)[:])
	if err != nil {
		err = msgp.WrapError(err, "Source")
		return
	}
	// write "dst"
	err = en.Append(0xa3, 0x64, 0x73, 0x74)
	if err != nil {
		return
	}
	err = en.WriteBytes((z.Destination)[:])
	if err != nil {
		err = msgp.WrapError(err, "Destination")
		return
	}
	// write "size"
	err = en.Append(0xa4, 0x73, 0x69, 0x7a, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Size)
	if err != nil {
		err = msgp.WrapError(err, "Size")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *MessageHeader) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 5
	// string "type"
	o = append(o, 0x85, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Type)
	// string "sig"
	o = append(o, 0xa3, 0x73, 0x69, 0x67)
	o = msgp.AppendBytes(o, z.Signature)
	// string "src"
	o = append(o, 0xa3, 0x73, 0x72, 0x63)
	o = msgp.AppendBytes(o, (z.Source)[:])
	// string "dst"
	o = append(o, 0xa3, 0x64, 0x73, 0x74)
	o = msgp.AppendBytes(o, (z.Destination)[:])
	// string "size"
	o = append(o, 0xa4, 0x73, 0x69, 0x7a, 0x65)
	o = msgp.AppendInt(o, z.Size)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MessageHeader) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "sig":
			z.Signature, bts, err = msgp.ReadBytesBytes(bts, z.Signature)
			if err != nil {
				err = msgp.WrapError(err, "Signature")
				return
			}
		case "src":
			bts, err = msgp.ReadExactBytes(bts, (z.Source)[:])
			if err != nil {
				err = msgp.WrapError(err, "Source")
				return
			}
		case "dst":
			bts, err = msgp.ReadExactBytes(bts, (z.Destination)[:])
			if err != nil {
				err = msgp.WrapError(err, "Destination")
				return
			}
		case "size":
			z.Size, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Size")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *MessageHeader) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Type) + 4 + msgp.BytesPrefixSize + len(z.Signature) + 4 + msgp.ArrayHeaderSize + (16 * (msgp.ByteSize)) + 4 + msgp.ArrayHeaderSize + (16 * (msgp.ByteSize)) + 5 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ReceiveMessages) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "filter":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Filter")
				return
			}
			if cap(z.Filter) >= int(zb0002) {
				z.Filter = (z.Filter)[:zb0002]
			} else {
				z.Filter = make([][16]byte, zb0002)
			}
			for za0001 := range z.Filter {
				err = dc.ReadExactBytes((z.Filter[za0001])[:])
				if err != nil {
					err = msgp.WrapError(err, "Filter", za0001)
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ReceiveMessages) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "filter"
	err = en.Append(0x81, 0xa6, 0x66, 0x69, 0x6c, 0x74, 0x65, 0x72)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Filter)))
	if err != nil {
		err = msgp.WrapError(err, "Filter")
		return
	}
	for za0001 := range z.Filter {
		err = en.WriteBytes((z.Filter[za0001])[:])
		if err != nil {
			err = msgp.WrapError(err, "Filter", za0001)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ReceiveMessages) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "filter"
	o = append(o, 0x81, 0xa6, 0x66, 0x69, 0x6c, 0x74, 0x65, 0x72)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Filter)))
	for za0001 := range z.Filter {
		o = msgp.AppendBytes(o, (z.Filter[za0001])[:])
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ReceiveMessages) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "filter":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Filter")
				return
			}
			if cap(z.Filter) >= int(zb0002) {
				z.Filter = (z.Filter)[:zb0002]
			} else {
				z.Filter = make([][16]byte, zb0002)
			}
			for za0001 := range z.Filter {
				bts, err = msgp.ReadExactBytes(bts, (z.Filter[za0001])[:])
				if err != nil {
					err = msgp.WrapError(err, "Filter", za0001)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ReceiveMessages) Msgsize() (s int) {
	s = 1 + 7 + msgp.ArrayHeaderSize + (len(z.Filter) * (16 * (msgp.ByteSize)))
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Register) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "sigkey":
			z.PublicSignatureKey, err = dc.ReadBytes(z.PublicSignatureKey)
			if err != nil {
				err = msgp.WrapError(err, "PublicSignatureKey")
				return
			}
		case "exchkey":
			z.PublicExchangeKey, err = dc.ReadBytes(z.PublicExchangeKey)
			if err != nil {
				err = msgp.WrapError(err, "PublicExchangeKey")
				return
			}
		case "name":
			z.Name, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "desc":
			z.Description, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Description")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Register) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 4
	// write "sigkey"
	err = en.Append(0x84, 0xa6, 0x73, 0x69, 0x67, 0x6b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteBytes(z.PublicSignatureKey)
	if err != nil {
		err = msgp.WrapError(err, "PublicSignatureKey")
		return
	}
	// write "exchkey"
	err = en.Append(0xa7, 0x65, 0x78, 0x63, 0x68, 0x6b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteBytes(z.PublicExchangeKey)
	if err != nil {
		err = msgp.WrapError(err, "PublicExchangeKey")
		return
	}
	// write "name"
	err = en.Append(0xa4, 0x6e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Name)
	if err != nil {
		err = msgp.WrapError(err, "Name")
		return
	}
	// write "desc"
	err = en.Append(0xa4, 0x64, 0x65, 0x73, 0x63)
	if err != nil {
		return
	}
	err = en.WriteString(z.Description)
	if err != nil {
		err = msgp.WrapError(err, "Description")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Register) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "sigkey"
	o = append(o, 0x84, 0xa6, 0x73, 0x69, 0x67, 0x6b, 0x65, 0x79)
	o = msgp.AppendBytes(o, z.PublicSignatureKey)
	// string "exchkey"
	o = append(o, 0xa7, 0x65, 0x78, 0x63, 0x68, 0x6b, 0x65, 0x79)
	o = msgp.AppendBytes(o, z.PublicExchangeKey)
	// string "name"
	o = append(o, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	// string "desc"
	o = append(o, 0xa4, 0x64, 0x65, 0x73, 0x63)
	o = msgp.AppendString(o, z.Description)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Register) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "sigkey":
			z.PublicSignatureKey, bts, err = msgp.ReadBytesBytes(bts, z.PublicSignatureKey)
			if err != nil {
				err = msgp.WrapError(err, "PublicSignatureKey")
				return
			}
		case "exchkey":
			z.PublicExchangeKey, bts, err = msgp.ReadBytesBytes(bts, z.PublicExchangeKey)
			if err != nil {
				err = msgp.WrapError(err, "PublicExchangeKey")
				return
			}
		case "name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "desc":
			z.Description, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Description")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Register) Msgsize() (s int) {
	s = 1 + 7 + msgp.BytesPrefixSize + len(z.PublicSignatureKey) + 8 + msgp.BytesPrefixSize + len(z.PublicExchangeKey) + 5 + msgp.StringPrefixSize + len(z.Name) + 5 + msgp.StringPrefixSize + len(z.Description)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *RegisterReply) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "addr":
			err = dc.ReadExactBytes((z.Address)[:])
			if err != nil {
				err = msgp.WrapError(err, "Address")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *RegisterReply) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "addr"
	err = en.Append(0x81, 0xa4, 0x61, 0x64, 0x64, 0x72)
	if err != nil {
		return
	}
	err = en.WriteBytes((z.Address)[:])
	if err != nil {
		err = msgp.WrapError(err, "Address")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *RegisterReply) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "addr"
	o = append(o, 0x81, 0xa4, 0x61, 0x64, 0x64, 0x72)
	o = msgp.AppendBytes(o, (z.Address)[:])
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *RegisterReply) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "addr":
			bts, err = msgp.ReadExactBytes(bts, (z.Address)[:])
			if err != nil {
				err = msgp.WrapError(err, "Address")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *RegisterReply) Msgsize() (s int) {
	s = 1 + 5 + msgp.ArrayHeaderSize + (16 * (msgp.ByteSize))
	return
}

// DecodeMsg implements msgp.Decodable
func (z *RequestConversation) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "name":
			z.Name, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "desc":
			z.Description, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Description")
				return
			}
		case "members":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Members")
				return
			}
			if cap(z.Members) >= int(zb0002) {
				z.Members = (z.Members)[:zb0002]
			} else {
				z.Members = make([][16]byte, zb0002)
			}
			for za0001 := range z.Members {
				err = dc.ReadExactBytes((z.Members[za0001])[:])
				if err != nil {
					err = msgp.WrapError(err, "Members", za0001)
					return
				}
			}
		case "private":
			z.Private, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Private")
				return
			}
		case "direct":
			z.Direct, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Direct")
				return
			}
		case "encrypted":
			z.Encrypted, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Encrypted")
				return
			}
		case "storable":
			z.Storable, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Storable")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *RequestConversation) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 7
	// write "name"
	err = en.Append(0x87, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Name)
	if err != nil {
		err = msgp.WrapError(err, "Name")
		return
	}
	// write "desc"
	err = en.Append(0xa4, 0x64, 0x65, 0x73, 0x63)
	if err != nil {
		return
	}
	err = en.WriteString(z.Description)
	if err != nil {
		err = msgp.WrapError(err, "Description")
		return
	}
	// write "members"
	err = en.Append(0xa7, 0x6d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Members)))
	if err != nil {
		err = msgp.WrapError(err, "Members")
		return
	}
	for za0001 := range z.Members {
		err = en.WriteBytes((z.Members[za0001])[:])
		if err != nil {
			err = msgp.WrapError(err, "Members", za0001)
			return
		}
	}
	// write "private"
	err = en.Append(0xa7, 0x70, 0x72, 0x69, 0x76, 0x61, 0x74, 0x65)
	if err != nil {
		return
	}
	err = en.WriteBool(z.Private)
	if err != nil {
		err = msgp.WrapError(err, "Private")
		return
	}
	// write "direct"
	err = en.Append(0xa6, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74)
	if err != nil {
		return
	}
	err = en.WriteBool(z.Direct)
	if err != nil {
		err = msgp.WrapError(err, "Direct")
		return
	}
	// write "encrypted"
	err = en.Append(0xa9, 0x65, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteBool(z.Encrypted)
	if err != nil {
		err = msgp.WrapError(err, "Encrypted")
		return
	}
	// write "storable"
	err = en.Append(0xa8, 0x73, 0x74, 0x6f, 0x72, 0x61, 0x62, 0x6c, 0x65)
	if err != nil {
		return
	}
	err = en.WriteBool(z.Storable)
	if err != nil {
		err = msgp.WrapError(err, "Storable")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *RequestConversation) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 7
	// string "name"
	o = append(o, 0x87, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	// string "desc"
	o = append(o, 0xa4, 0x64, 0x65, 0x73, 0x63)
	o = msgp.AppendString(o, z.Description)
	// string "members"
	o = append(o, 0xa7, 0x6d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Members)))
	for za0001 := range z.Members {
		o = msgp.AppendBytes(o, (z.Members[za0001])[:])
	}
	// string "private"
	o = append(o, 0xa7, 0x70, 0x72, 0x69, 0x76, 0x61, 0x74, 0x65)
	o = msgp.AppendBool(o, z.Private)
	// string "direct"
	o = append(o, 0xa6, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74)
	o = msgp.AppendBool(o, z.Direct)
	// string "encrypted"
	o = append(o, 0xa9, 0x65, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64)
	o = msgp.AppendBool(o, z.Encrypted)
	// string "storable"
	o = append(o, 0xa8, 0x73, 0x74, 0x6f, 0x72, 0x61, 0x62, 0x6c, 0x65)
	o = msgp.AppendBool(o, z.Storable)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *RequestConversation) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "desc":
			z.Description, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Description")
				return
			}
		case "members":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Members")
				return
			}
			if cap(z.Members) >= int(zb0002) {
				z.Members = (z.Members)[:zb0002]
			} else {
				z.Members = make([][16]byte, zb0002)
			}
			for za0001 := range z.Members {
				bts, err = msgp.ReadExactBytes(bts, (z.Members[za0001])[:])
				if err != nil {
					err = msgp.WrapError(err, "Members", za0001)
					return
				}
			}
		case "private":
			z.Private, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Private")
				return
			}
		case "direct":
			z.Direct, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Direct")
				return
			}
		case "encrypted":
			z.Encrypted, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Encrypted")
				return
			}
		case "storable":
			z.Storable, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Storable")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *RequestConversation) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Name) + 5 + msgp.StringPrefixSize + len(z.Description) + 8 + msgp.ArrayHeaderSize + (len(z.Members) * (16 * (msgp.ByteSize))) + 8 + msgp.BoolSize + 7 + msgp.BoolSize + 10 + msgp.BoolSize + 9 + msgp.BoolSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *RequestConversationReply) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "addr":
			err = dc.ReadExactBytes((z.Address)[:])
			if err != nil {
				err = msgp.WrapError(err, "Address")
				return
			}
		case "members":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Members")
				return
			}
			if cap(z.Members) >= int(zb0002) {
				z.Members = (z.Members)[:zb0002]
			} else {
				z.Members = make([][16]byte, zb0002)
			}
			for za0002 := range z.Members {
				err = dc.ReadExactBytes((z.Members[za0002])[:])
				if err != nil {
					err = msgp.WrapError(err, "Members", za0002)
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *RequestConversationReply) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "addr"
	err = en.Append(0x82, 0xa4, 0x61, 0x64, 0x64, 0x72)
	if err != nil {
		return
	}
	err = en.WriteBytes((z.Address)[:])
	if err != nil {
		err = msgp.WrapError(err, "Address")
		return
	}
	// write "members"
	err = en.Append(0xa7, 0x6d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Members)))
	if err != nil {
		err = msgp.WrapError(err, "Members")
		return
	}
	for za0002 := range z.Members {
		err = en.WriteBytes((z.Members[za0002])[:])
		if err != nil {
			err = msgp.WrapError(err, "Members", za0002)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *RequestConversationReply) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "addr"
	o = append(o, 0x82, 0xa4, 0x61, 0x64, 0x64, 0x72)
	o = msgp.AppendBytes(o, (z.Address)[:])
	// string "members"
	o = append(o, 0xa7, 0x6d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Members)))
	for za0002 := range z.Members {
		o = msgp.AppendBytes(o, (z.Members[za0002])[:])
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *RequestConversationReply) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "addr":
			bts, err = msgp.ReadExactBytes(bts, (z.Address)[:])
			if err != nil {
				err = msgp.WrapError(err, "Address")
				return
			}
		case "members":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Members")
				return
			}
			if cap(z.Members) >= int(zb0002) {
				z.Members = (z.Members)[:zb0002]
			} else {
				z.Members = make([][16]byte, zb0002)
			}
			for za0002 := range z.Members {
				bts, err = msgp.ReadExactBytes(bts, (z.Members[za0002])[:])
				if err != nil {
					err = msgp.WrapError(err, "Members", za0002)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *RequestConversationReply) Msgsize() (s int) {
	s = 1 + 5 + msgp.ArrayHeaderSize + (16 * (msgp.ByteSize)) + 8 + msgp.ArrayHeaderSize + (len(z.Members) * (16 * (msgp.ByteSize)))
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ResolveAddress) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "addr":
			err = dc.ReadExactBytes((z.Address)[:])
			if err != nil {
				err = msgp.WrapError(err, "Address")
				return
			}
		case "key":
			z.DiscoverKey, err = dc.ReadBytes(z.DiscoverKey)
			if err != nil {
				err = msgp.WrapError(err, "DiscoverKey")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ResolveAddress) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "addr"
	err = en.Append(0x82, 0xa4, 0x61, 0x64, 0x64, 0x72)
	if err != nil {
		return
	}
	err = en.WriteBytes((z.Address)[:])
	if err != nil {
		err = msgp.WrapError(err, "Address")
		return
	}
	// write "key"
	err = en.Append(0xa3, 0x6b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteBytes(z.DiscoverKey)
	if err != nil {
		err = msgp.WrapError(err, "DiscoverKey")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ResolveAddress) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "addr"
	o = append(o, 0x82, 0xa4, 0x61, 0x64, 0x64, 0x72)
	o = msgp.AppendBytes(o, (z.Address)[:])
	// string "key"
	o = append(o, 0xa3, 0x6b, 0x65, 0x79)
	o = msgp.AppendBytes(o, z.DiscoverKey)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ResolveAddress) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "addr":
			bts, err = msgp.ReadExactBytes(bts, (z.Address)[:])
			if err != nil {
				err = msgp.WrapError(err, "Address")
				return
			}
		case "key":
			z.DiscoverKey, bts, err = msgp.ReadBytesBytes(bts, z.DiscoverKey)
			if err != nil {
				err = msgp.WrapError(err, "DiscoverKey")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ResolveAddress) Msgsize() (s int) {
	s = 1 + 5 + msgp.ArrayHeaderSize + (16 * (msgp.ByteSize)) + 4 + msgp.BytesPrefixSize + len(z.DiscoverKey)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ResolveAddressReply) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z ResolveAddressReply) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "type"
	err = en.Append(0x81, 0xa4, 0x74, 0x79, 0x70, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Type)
	if err != nil {
		err = msgp.WrapError(err, "Type")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z ResolveAddressReply) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "type"
	o = append(o, 0x81, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Type)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ResolveAddressReply) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z ResolveAddressReply) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Type)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ResolveDevice) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "addr":
			err = dc.ReadExactBytes((z.Address)[:])
			if err != nil {
				err = msgp.WrapError(err, "Address")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ResolveDevice) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "addr"
	err = en.Append(0x81, 0xa4, 0x61, 0x64, 0x64, 0x72)
	if err != nil {
		return
	}
	err = en.WriteBytes((z.Address)[:])
	if err != nil {
		err = msgp.WrapError(err, "Address")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ResolveDevice) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "addr"
	o = append(o, 0x81, 0xa4, 0x61, 0x64, 0x64, 0x72)
	o = msgp.AppendBytes(o, (z.Address)[:])
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ResolveDevice) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "addr":
			bts, err = msgp.ReadExactBytes(bts, (z.Address)[:])
			if err != nil {
				err = msgp.WrapError(err, "Address")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ResolveDevice) Msgsize() (s int) {
	s = 1 + 5 + msgp.ArrayHeaderSize + (16 * (msgp.ByteSize))
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ResolveDeviceReply) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "name":
			z.Name, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "desc":
			z.Description, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Description")
				return
			}
		case "sigkey":
			z.SignatureKey, err = dc.ReadBytes(z.SignatureKey)
			if err != nil {
				err = msgp.WrapError(err, "SignatureKey")
				return
			}
		case "exchkey":
			z.ExchangeKey, err = dc.ReadBytes(z.ExchangeKey)
			if err != nil {
				err = msgp.WrapError(err, "ExchangeKey")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ResolveDeviceReply) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 4
	// write "name"
	err = en.Append(0x84, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Name)
	if err != nil {
		err = msgp.WrapError(err, "Name")
		return
	}
	// write "desc"
	err = en.Append(0xa4, 0x64, 0x65, 0x73, 0x63)
	if err != nil {
		return
	}
	err = en.WriteString(z.Description)
	if err != nil {
		err = msgp.WrapError(err, "Description")
		return
	}
	// write "sigkey"
	err = en.Append(0xa6, 0x73, 0x69, 0x67, 0x6b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteBytes(z.SignatureKey)
	if err != nil {
		err = msgp.WrapError(err, "SignatureKey")
		return
	}
	// write "exchkey"
	err = en.Append(0xa7, 0x65, 0x78, 0x63, 0x68, 0x6b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteBytes(z.ExchangeKey)
	if err != nil {
		err = msgp.WrapError(err, "ExchangeKey")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ResolveDeviceReply) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "name"
	o = append(o, 0x84, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	// string "desc"
	o = append(o, 0xa4, 0x64, 0x65, 0x73, 0x63)
	o = msgp.AppendString(o, z.Description)
	// string "sigkey"
	o = append(o, 0xa6, 0x73, 0x69, 0x67, 0x6b, 0x65, 0x79)
	o = msgp.AppendBytes(o, z.SignatureKey)
	// string "exchkey"
	o = append(o, 0xa7, 0x65, 0x78, 0x63, 0x68, 0x6b, 0x65, 0x79)
	o = msgp.AppendBytes(o, z.ExchangeKey)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ResolveDeviceReply) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "desc":
			z.Description, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Description")
				return
			}
		case "sigkey":
			z.SignatureKey, bts, err = msgp.ReadBytesBytes(bts, z.SignatureKey)
			if err != nil {
				err = msgp.WrapError(err, "SignatureKey")
				return
			}
		case "exchkey":
			z.ExchangeKey, bts, err = msgp.ReadBytesBytes(bts, z.ExchangeKey)
			if err != nil {
				err = msgp.WrapError(err, "ExchangeKey")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ResolveDeviceReply) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Name) + 5 + msgp.StringPrefixSize + len(z.Description) + 7 + msgp.BytesPrefixSize + len(z.SignatureKey) + 8 + msgp.BytesPrefixSize + len(z.ExchangeKey)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *SendMessage) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "text":
			z.Text, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Text")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z SendMessage) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "text"
	err = en.Append(0x81, 0xa4, 0x74, 0x65, 0x78, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Text)
	if err != nil {
		err = msgp.WrapError(err, "Text")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z SendMessage) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "text"
	o = append(o, 0x81, 0xa4, 0x74, 0x65, 0x78, 0x74)
	o = msgp.AppendString(o, z.Text)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *SendMessage) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "text":
			z.Text, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Text")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z SendMessage) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Text)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *SendMessageReply) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "id":
			z.MessageID, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "MessageID")
				return
			}
		case "sent_at":
			z.SentAt, err = dc.ReadTime()
			if err != nil {
				err = msgp.WrapError(err, "SentAt")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z SendMessageReply) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "id"
	err = en.Append(0x82, 0xa2, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.MessageID)
	if err != nil {
		err = msgp.WrapError(err, "MessageID")
		return
	}
	// write "sent_at"
	err = en.Append(0xa7, 0x73, 0x65, 0x6e, 0x74, 0x5f, 0x61, 0x74)
	if err != nil {
		return
	}
	err = en.WriteTime(z.SentAt)
	if err != nil {
		err = msgp.WrapError(err, "SentAt")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z SendMessageReply) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "id"
	o = append(o, 0x82, 0xa2, 0x69, 0x64)
	o = msgp.AppendUint64(o, z.MessageID)
	// string "sent_at"
	o = append(o, 0xa7, 0x73, 0x65, 0x6e, 0x74, 0x5f, 0x61, 0x74)
	o = msgp.AppendTime(o, z.SentAt)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *SendMessageReply) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "id":
			z.MessageID, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MessageID")
				return
			}
		case "sent_at":
			z.SentAt, bts, err = msgp.ReadTimeBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SentAt")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z SendMessageReply) Msgsize() (s int) {
	s = 1 + 3 + msgp.Uint64Size + 8 + msgp.TimeSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *SetDiscoveryKey) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "key":
			z.DiscoveryKey, err = dc.ReadBytes(z.DiscoveryKey)
			if err != nil {
				err = msgp.WrapError(err, "DiscoveryKey")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *SetDiscoveryKey) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "key"
	err = en.Append(0x81, 0xa3, 0x6b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteBytes(z.DiscoveryKey)
	if err != nil {
		err = msgp.WrapError(err, "DiscoveryKey")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *SetDiscoveryKey) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "key"
	o = append(o, 0x81, 0xa3, 0x6b, 0x65, 0x79)
	o = msgp.AppendBytes(o, z.DiscoveryKey)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *SetDiscoveryKey) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "key":
			z.DiscoveryKey, bts, err = msgp.ReadBytesBytes(bts, z.DiscoveryKey)
			if err != nil {
				err = msgp.WrapError(err, "DiscoveryKey")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *SetDiscoveryKey) Msgsize() (s int) {
	s = 1 + 4 + msgp.BytesPrefixSize + len(z.DiscoveryKey)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *SetDiscoveryKeyReply) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z SetDiscoveryKeyReply) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 0
	err = en.Append(0x80)
	if err != nil {
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z SetDiscoveryKeyReply) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 0
	o = append(o, 0x80)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *SetDiscoveryKeyReply) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z SetDiscoveryKeyReply) Msgsize() (s int) {
	s = 1
	return
}

// DecodeMsg implements msgp.Decodable
func (z *SetEncoding) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z SetEncoding) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "type"
	err = en.Append(0x81, 0xa4, 0x74, 0x79, 0x70, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Type)
	if err != nil {
		err = msgp.WrapError(err, "Type")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z SetEncoding) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "type"
	o = append(o, 0x81, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Type)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *SetEncoding) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z SetEncoding) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Type)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *SetPrivacySettings) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "discoverable":
			z.Discoverable, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Discoverable")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z SetPrivacySettings) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "discoverable"
	err = en.Append(0x81, 0xac, 0x64, 0x69, 0x73, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x61, 0x62, 0x6c, 0x65)
	if err != nil {
		return
	}
	err = en.WriteBool(z.Discoverable)
	if err != nil {
		err = msgp.WrapError(err, "Discoverable")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z SetPrivacySettings) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "discoverable"
	o = append(o, 0x81, 0xac, 0x64, 0x69, 0x73, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x61, 0x62, 0x6c, 0x65)
	o = msgp.AppendBool(o, z.Discoverable)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *SetPrivacySettings) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "discoverable":
			z.Discoverable, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Discoverable")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z SetPrivacySettings) Msgsize() (s int) {
	s = 1 + 13 + msgp.BoolSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *SetPrivacySettingsReply) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z SetPrivacySettingsReply) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 0
	err = en.Append(0x80)
	if err != nil {
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z SetPrivacySettingsReply) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 0
	o = append(o, 0x80)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *SetPrivacySettingsReply) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z SetPrivacySettingsReply) Msgsize() (s int) {
	s = 1
	return
}
